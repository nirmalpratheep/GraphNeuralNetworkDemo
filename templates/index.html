<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>GNN Interactive Demo</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #controls      const w = 380, h = 380;  // Increased size for better visibility
      const nodes = graph.nodes;
      const links = graph.links;

      const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 70;  // Adjusted radius for larger spacingrgin-bottom: 20px; }
    #graph-initial, #graph-final, [id^="graph-layer-"] { width: 380px; height: 380px; border: 1px solid #ddd; margin: 0 auto; }
    .node { cursor: pointer; }
    #timeline { margin-top: 20px; }
    .bar { height: 12px; background: steelblue; margin: 3px 0; }
    #calculations { padding: 15px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-height: 80vh; overflow-y: auto; }
    .calculation-step { margin: 10px 0; padding: 12px; background: white; border-left: 4px solid #007acc; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: transform 0.2s ease; }
    .calculation-step:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .formula { font-family: 'Courier New', monospace; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 8px; border-radius: 6px; margin: 6px 0; font-weight: bold; font-size: 0.9em; }
    .node-calculation { background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 8px; padding: 10px; margin: 6px 0; transition: all 0.3s ease; }
    .node-calculation:hover { border-color: #007acc; background: #e3f2fd; }
    .node-header { background: #007acc; color: white; padding: 6px 10px; border-radius: 6px; font-weight: bold; margin: -10px -10px 6px -10px; font-size: 0.9em; }
    .calculation-detail { margin: 4px 0; padding: 4px 8px; background: #fff; border-left: 3px solid #28a745; border-radius: 4px; font-size: 0.85em; }
    .neighbor-list { display: inline-block; background: #ffc107; color: #000; padding: 1px 6px; border-radius: 10px; font-size: 0.8em; font-weight: bold; }
    .value-highlight { background: #17a2b8; color: white; padding: 1px 4px; border-radius: 3px; font-weight: bold; font-size: 0.85em; }
    .layer-flow { display: flex; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    .layer-arrow { font-size: 18px; color: #007acc; margin: 0 5px; }
    .transformation-box { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); border-radius: 6px; padding: 6px; margin: 3px 0; font-size: 0.85em; }
  </style>
</head>
<body>
  <h2>Simple GNN Interactive Demo</h2>
  <div id="controls">
    <div style="margin-bottom: 15px;">
      <label>Nodes: </label>
      <input type="number" id="numNodes" min="1" max="10" value="6" style="width: 60px;">
      <label style="margin-left: 15px;">Edges: </label>
      <input type="number" id="numEdges" min="1" max="20" value="10" style="width: 60px;">
      <button id="newGraph" style="margin-left: 10px;">New Graph</button>
    </div>
    <div>
      Model:
      <select id="model">
        <option>GCN</option>
        <option>GAN</option>
        <option>GIN</option>
        <option>GraphSage</option>
      </select>
      Layers:
      <select id="layers">
        <option>1</option>
        <option selected>2</option>
        <option>3</option>
        <option>4</option>
      </select>
      Pooling:
      <select id="pooling">
        <option value="max">max</option>
        <option value="mean" selected>mean</option>
        <option value="attention">attention</option>
      </select>
      <button id="run">Run Model</button>
    </div>
  </div>

  <div style="display:flex;gap:20px;align-items:flex-start;min-height:600px;">
    <div style="flex:1;">
      <div id="graph-visualizations"></div>
      <div id="timeline"></div>
    </div>
    <div style="flex:1;min-width:400px;">
      <div id="calculations"></div>
    </div>
  </div>

  <script>
    async function fetchCompute() {
      const model = document.getElementById('model').value;
      const layers = document.getElementById('layers').value;
      const pooling = document.getElementById('pooling').value;

      try {
        const res = await fetch('/compute', {
          method: 'POST', 
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({model, layers, pooling}),
          cache: 'no-cache'
        });
        if (!res.ok) throw new Error('Server returned ' + res.status);
        return await res.json();
      } catch (err) {
        console.error('Fetch error:', err);
        document.getElementById('status').textContent = 'Server not reachable — using local fallback demo.';
        return null;
      }
    }

    function localCompute() {
      const model = document.getElementById('model').value;
      const layers = parseInt(document.getElementById('layers').value, 10);
      const pooling = document.getElementById('pooling').value;

      const N = parseInt(document.getElementById('numNodes').value);
      const targetEdges = parseInt(document.getElementById('numEdges').value);
      
      // Use seeded RNG for consistent results
      const seededRandom = (seed=>{
        let s=seed;
        return () => {
          s=(s*1664525+1013904223)>>>0;
          return s/4294967296;
        };
      })(42);

      // Create edges ensuring connectivity
      const edges = [];
      const edgeSet = new Set();
      
      // First ensure connectivity with a simple path
      for (let i = 0; i < N-1; i++) {
        const key = i + ',' + (i+1);
        edgeSet.add(key);
      }
      
      // Add remaining random edges
      while (edgeSet.size < targetEdges && edgeSet.size < (N * (N-1))/2) {
        let a = Math.floor(seededRandom() * N);
        let b = Math.floor(seededRandom() * N);
        if (a === b) continue;
        const key = a<b ? `${a},${b}` : `${b},${a}`;
        edgeSet.add(key);
      }
      
      edgeSet.forEach(k => {
        const [a,b] = k.split(',');
        edges.push({source: parseInt(a), target: parseInt(b)});
      });

      const graph = {
        nodes: Array.from({length:N}, (_,i) => ({id:i})),
        links: edges
      };
      
      // Use seeded random for consistent initial embeddings
      let emb = Array.from({length:N}, () => 0.5 + 1.5 * seededRandom());
      const timeline = [{layer:0, embeddings:emb.slice(), ops:[]}];

      function applyLayerJS(graph, embeddings, layerNum) {
        const N = embeddings.length;
        const newEmb = new Array(N).fill(0);
        const ops = [];
        
        for (let node=0; node<N; node++) {
          const neigh = graph.links
            .filter(l => l.source===node || l.target===node)
            .map(l => l.source===node ? l.target : l.source);
          
          const neigh_vals = neigh.map(i => embeddings[i]);
          let pooled = 0;
          
          if (neigh_vals.length > 0) {
            if (pooling==='mean') {
              pooled = neigh_vals.reduce((a,b) => a+b, 0) / neigh_vals.length;
            }
            else if (pooling==='max') {
              pooled = Math.max(...neigh_vals);
            }
            else { // attention
              const scores = neigh_vals.map(v => Math.exp(v));
              const s = scores.reduce((a,b) => a+b, 0);
              pooled = neigh_vals.reduce((sum,v,i) => sum + v*(scores[i]/s), 0);
            }
          }

          let updated = embeddings[node];
          if (model==='GCN') {
            updated = 0.5*embeddings[node] + 0.5*pooled;
          }
          else if (model==='GIN') {
            updated = 1.2*embeddings[node] + 0.8*pooled;
          }
          else if (model==='GraphSage') {
            updated = Math.tanh(embeddings[node] + pooled);
          }
          else if (model==='GAN') {
            const gate = 1/(1+Math.exp(-embeddings[node]));
            updated = gate*embeddings[node] + (1-gate)*pooled;
          }

          newEmb[node] = updated;
          ops.push({
            node: node,
            self: embeddings[node],
            pooled: pooled,
            updated: updated,
            neighbors: neigh
          });
        }
        return [newEmb, ops];
      }

      for (let L=1; L<=layers; L++) {
        const [newEmb, ops] = applyLayerJS(graph, emb, L);
        emb = newEmb;
        timeline.push({layer:L, embeddings:emb.slice(), ops:ops});
      }

      return {graph, timeline};
    }

    function drawGraph(targetId, graph, embeddings, initialEmbeddings = null) {
      try {
        const w = 280, h = 280;
        const nodes = graph.nodes;
        const links = graph.links;

        const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 50;
        const angle = (i) => 2 * Math.PI * i / nodes.length;

        let html = '<svg width="'+w+'" height="'+h+'">';
        
        // links first (under nodes)
        links.forEach(l => {
          const a = l.source, b = l.target;
          const ax = cx + r * Math.cos(angle(a));
          const ay = cy + r * Math.sin(angle(a));
          const bx = cx + r * Math.cos(angle(b));
          const by = cy + r * Math.sin(angle(b));
          html += '<line x1="'+ax+'" y1="'+ay+'" x2="'+bx+'" y2="'+by+'" stroke="#999" stroke-width="1" />';
        });

        // Calculate dynamic node sizes based on embedding values
        const minv = Math.min(...embeddings);
        const maxv = Math.max(...embeddings);
        const norm = (v) => (maxv===minv) ? 0.5 : (v - minv)/(maxv-minv);
        
        // Constant node size
        const nodeSize = 20;  // Fixed size for all nodes

        nodes.forEach(n => {
          const i = n.id;
          const x = cx + r * Math.cos(angle(i));
          const y = cy + r * Math.sin(angle(i));
          const v = embeddings[i];
          const t = norm(v);
          
          // Color based on embedding value
          const color = 'rgb(' + Math.round(255 * t) + ',0,' + Math.round(255*(1-t)) + ')';
          
          // Add change indicator if initial embeddings provided
          let changeIndicator = '';
          if (initialEmbeddings) {
            const change = v - initialEmbeddings[i];
            const changePercent = ((change / initialEmbeddings[i]) * 100).toFixed(0);
            changeIndicator = change >= 0 ? '↗' : '↘';
          }
          
          html += '<g class="node" transform="translate('+x+','+y+')">';
          // Node circle
          html += '<circle r="'+nodeSize+'" fill="'+color+'" stroke="#222" stroke-width="2" />';
          // Node ID - bigger and outside the circle
          html += '<text x="0" y="-'+(nodeSize + 8)+'" text-anchor="middle" font-size="12" fill="#000" font-weight="bold" style="filter: drop-shadow(0 0 2px white)">ID: '+i+'</text>';
          // Node value - centered in circle
          html += '<text x="0" y="4" text-anchor="middle" font-size="10" fill="#fff" font-weight="bold" style="filter: drop-shadow(0 0 1px black)">'+v.toFixed(2)+'</text>';
          // Change indicator - more visible
          if (changeIndicator) {
            html += '<text x="'+(nodeSize + 5)+'" y="0" text-anchor="start" font-size="12" fill="#ff6b6b" font-weight="bold" style="filter: drop-shadow(0 0 2px white)">'+changeIndicator+'</text>';
          }
          html += '</g>';
        });

        html += '</svg>';
        document.getElementById(targetId).innerHTML = html;
      } catch (err) {
        console.error('drawGraph error:', err);
        const el = document.getElementById(targetId);
        if (el) el.innerHTML = '<div style="color:crimson">Error drawing graph: '+(err.message||err)+'</div>';
      }
    }

    function drawAllLayers(timeline, graph) {
      try {
        let html = '<h3>🔄 Layer-by-Layer Transformation</h3>';
        html += '<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;">';
        
        timeline.forEach((frame, idx) => {
          const layerTitle = frame.layer === 0 ? 'Initial' : `Layer ${frame.layer}`;
          html += '<div style="text-align: center;">';
          html += '<h4 style="margin: 5px 0; font-size: 14px; color: #333;">' + layerTitle + '</h4>';
          html += '<div id="graph-layer-' + frame.layer + '" style="border: 2px solid #ddd; border-radius: 8px; background: #fafafa;"></div>';
          html += '</div>';
        });
        
        html += '</div>';
        document.getElementById('graph-visualizations').innerHTML = html;
        
        // Draw each layer
        const initialEmbeddings = timeline[0].embeddings;
        timeline.forEach((frame, idx) => {
          drawGraph('graph-layer-' + frame.layer, graph, frame.embeddings, initialEmbeddings);
        });
      } catch (err) {
        console.error('drawAllLayers error:', err);
        document.getElementById('graph-visualizations').innerHTML = '<div style="color:crimson">Error drawing layers: '+(err.message||err)+'</div>';
      }
    }

    function showTimeline(timeline) {
      try {
        let html = '';
        timeline.forEach(frame => {
          html += '<div><strong>Layer '+frame.layer+'</strong></div>';
          html += '<div style="width:600px">';
          const emb = frame.embeddings;
          const max = Math.max(...emb);
          for (let i=0; i<emb.length; i++) {
            const w = Math.max(1, Math.round((emb[i]/(max||1))*500));
            html += '<div style="display:flex;align-items:center">';
            html += '<div style="width:40px">#'+i+'</div>';
            html += '<div class="bar" style="width:'+w+'px"></div>';
            html += '<div style="width:80px;margin-left:8px">'+emb[i].toFixed(3)+'</div>';
            html += '</div>';
          }
          html += '</div>';
        });
        document.getElementById('timeline').innerHTML = html;
      } catch (err) {
        console.error('showTimeline error:', err);
        const el = document.getElementById('timeline');
        if (el) el.innerHTML = '<div style="color:crimson">Error rendering timeline: '+(err.message||err)+'</div>';
      }
    }

    function showCalculations(timeline, model, pooling) {
      try {
        let html = '<h3>🧮 Calculation Details & Node Transformations</h3>';
        
        // Show the general formula for the selected model
        html += '<div class="calculation-step">';
        html += '<h4>📊 Model Configuration</h4>';
        html += '<div style="display: flex; gap: 20px; margin: 10px 0;">';
        html += '<div><strong>Model:</strong> <span class="value-highlight">' + model + '</span></div>';
        html += '<div><strong>Pooling:</strong> <span class="value-highlight">' + pooling + '</span></div>';
        html += '<div><strong>Layers:</strong> <span class="value-highlight">' + (timeline.length - 1) + '</span></div>';
        html += '</div>';
        
        if (model === 'GCN') {
          html += '<div class="formula">🔄 GCN Update: updated = 0.5 × self + 0.5 × pooled_neighbors</div>';
        } else if (model === 'GIN') {
          html += '<div class="formula">🔄 GIN Update: updated = 1.2 × self + 0.8 × pooled_neighbors</div>';
        } else if (model === 'GraphSage') {
          html += '<div class="formula">🔄 GraphSage Update: updated = tanh(self + pooled_neighbors)</div>';
        } else if (model === 'GAN') {
          html += '<div class="formula">🔄 GAN Update: gate = 1/(1 + exp(-self))<br>updated = gate × self + (1-gate) × pooled_neighbors</div>';
        }
        
        if (pooling === 'mean') {
          html += '<div class="formula">📊 Mean Pooling: pooled_neighbors = mean(neighbor_values)</div>';
        } else if (pooling === 'max') {
          html += '<div class="formula">📊 Max Pooling: pooled_neighbors = max(neighbor_values)</div>';
        } else if (pooling === 'attention') {
          html += '<div class="formula">📊 Attention Pooling: scores = exp(neighbor_values)<br>weights = scores / sum(scores)<br>pooled_neighbors = sum(weights × neighbor_values)</div>';
        }
        html += '</div>';

        // Show node transformation flow
        html += '<div class="calculation-step">';
        html += '<h4>🔄 Node Transformation Flow</h4>';
        
        // Create a transformation flow for each node
        const numNodes = timeline[0].embeddings.length;
        for (let nodeId = 0; nodeId < numNodes; nodeId++) { // Show all nodes
          html += '<div class="node-calculation">';
          html += '<div class="node-header">Node ' + nodeId + ' Transformation Journey</div>';
          
          // Show initial value
          html += '<div class="layer-flow">';
          html += '<div class="transformation-box">';
          html += '<strong>Initial:</strong> <span class="value-highlight">' + timeline[0].embeddings[nodeId].toFixed(3) + '</span>';
          html += '</div>';
          
          // Show each layer transformation
          for (let layerIdx = 1; layerIdx < timeline.length; layerIdx++) {
            const frame = timeline[layerIdx];
            const prevValue = timeline[layerIdx - 1].embeddings[nodeId];
            const currValue = frame.embeddings[nodeId];
            const change = currValue - prevValue;
            const changePercent = ((change / prevValue) * 100).toFixed(1);
            
            html += '<div class="layer-arrow">→</div>';
            html += '<div class="transformation-box">';
            html += '<strong>Layer ' + layerIdx + ':</strong> ';
            html += '<span class="value-highlight">' + currValue.toFixed(3) + '</span>';
            html += ' <span style="color: ' + (change >= 0 ? '#28a745' : '#dc3545') + '; font-weight: bold;">';
            html += '(' + (change >= 0 ? '+' : '') + change.toFixed(3) + ', ' + changePercent + '%)</span>';
            html += '</div>';
          }
          html += '</div>';
          html += '</div>';
        }
        html += '</div>';

        // Show detailed calculations for each layer
        timeline.forEach((frame, layerIdx) => {
          if (frame.layer === 0) return; // Skip initial layer
          
          html += '<div class="calculation-step">';
          html += '<h4>🔍 Layer ' + frame.layer + ' Detailed Calculations</h4>';
          
          if (frame.ops && frame.ops.length > 0) {
            // Show calculations for all nodes in detail
            for (let i = 0; i < frame.ops.length; i++) {
              const op = frame.ops[i];
              html += '<div class="node-calculation">';
              html += '<div class="node-header">Node ' + op.node + ' Calculation</div>';
              
              html += '<div class="calculation-detail">';
              html += '<strong>🔹 Self Value:</strong> <span class="value-highlight">' + op.self.toFixed(3) + '</span>';
              html += '</div>';
              
              html += '<div class="calculation-detail">';
              html += '<strong>🔗 Neighbors:</strong> <span class="neighbor-list">[' + op.neighbors.join(', ') + ']</span>';
              html += '</div>';
              
              html += '<div class="calculation-detail">';
              html += '<strong>📊 Pooled (' + pooling + '):</strong> <span class="value-highlight">' + op.pooled.toFixed(3) + '</span>';
              html += '</div>';
              
              // Show the specific calculation based on model
              html += '<div class="calculation-detail">';
              html += '<strong>🧮 Calculation:</strong> ';
              if (model === 'GCN') {
                html += '0.5 × <span class="value-highlight">' + op.self.toFixed(3) + '</span> + 0.5 × <span class="value-highlight">' + op.pooled.toFixed(3) + '</span> = <span class="value-highlight">' + op.updated.toFixed(3) + '</span>';
              } else if (model === 'GIN') {
                html += '1.2 × <span class="value-highlight">' + op.self.toFixed(3) + '</span> + 0.8 × <span class="value-highlight">' + op.pooled.toFixed(3) + '</span> = <span class="value-highlight">' + op.updated.toFixed(3) + '</span>';
              } else if (model === 'GraphSage') {
                html += 'tanh(<span class="value-highlight">' + op.self.toFixed(3) + '</span> + <span class="value-highlight">' + op.pooled.toFixed(3) + '</span>) = <span class="value-highlight">' + op.updated.toFixed(3) + '</span>';
              } else if (model === 'GAN') {
                const gate = 1/(1+Math.exp(-op.self));
                html += '<br>Gate: 1/(1 + exp(-<span class="value-highlight">' + op.self.toFixed(3) + '</span>)) = <span class="value-highlight">' + gate.toFixed(3) + '</span><br>';
                html += gate.toFixed(3) + ' × <span class="value-highlight">' + op.self.toFixed(3) + '</span> + (1-' + gate.toFixed(3) + ') × <span class="value-highlight">' + op.pooled.toFixed(3) + '</span> = <span class="value-highlight">' + op.updated.toFixed(3) + '</span>';
              }
              html += '</div>';
              html += '</div>';
            }
          } else {
            // Fallback: show embedding values
            html += '<div style="color: #6c757d; font-style: italic;">Detailed operations not available, showing final values:</div>';
            frame.embeddings.forEach((val, idx) => {
              html += '<div class="calculation-detail">Node ' + idx + ': <span class="value-highlight">' + val.toFixed(3) + '</span></div>';
            });
          }
          html += '</div>';
        });
        
        document.getElementById('calculations').innerHTML = html;
      } catch (err) {
        console.error('showCalculations error:', err);
        const el = document.getElementById('calculations');
        if (el) el.innerHTML = '<div style="color:crimson">Error showing calculations: '+(err.message||err)+'</div>';
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      console.log('Page loaded, initializing...');
      const statusEl = document.createElement('div');
      statusEl.id = 'status';
      statusEl.style.marginBottom = '8px';
      document.getElementById('controls').appendChild(statusEl);

      // Show placeholder for graph visualizations
      const graphEl = document.getElementById('graph-visualizations');
      if (graphEl) graphEl.innerHTML = '<div style="text-align: center; padding: 50px; color: #666;">Loading graph visualizations...</div>';

      // Add input validation and update handlers
      const numNodesInput = document.getElementById('numNodes');
      const numEdgesInput = document.getElementById('numEdges');
      
      function updateMaxEdges() {
        const n = parseInt(numNodesInput.value);
        const maxPossible = (n * (n-1)) / 2;
        numEdgesInput.max = Math.min(20, maxPossible);
        if (parseInt(numEdgesInput.value) > numEdgesInput.max) {
          numEdgesInput.value = numEdgesInput.max;
        }
      }
      
      numNodesInput.addEventListener('change', updateMaxEdges);
      updateMaxEdges(); // Initial update

      async function runOnce(regenerate = false) {
        try {
          document.getElementById('status').textContent = 'Running...';
          const nodes = parseInt(numNodesInput.value);
          const edges = parseInt(numEdgesInput.value);
          
          const params = {
            model: document.getElementById('model').value,
            layers: document.getElementById('layers').value,
            pooling: document.getElementById('pooling').value,
            nodes: nodes,
            edges: edges,
            regenerate: regenerate
          };
          
          const res = await fetch('/compute', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(params),
            cache: 'no-cache'
          });
          
          let payload = await res.json();
          if (!res.ok) throw new Error('Server returned ' + res.status);
          
          if (!payload) {
            payload = localCompute();
            document.getElementById('status').textContent = 'Using local fallback (server unreachable)';
          } else {
            document.getElementById('status').textContent = '';
          }

          const timeline = payload.timeline;
          if (!timeline || !timeline.length) throw new Error('No timeline returned');
          
          // Draw all layers with dynamic sizing
          drawAllLayers(timeline, payload.graph);
          showTimeline(timeline);
          
          // Show detailed calculations
          const model = document.getElementById('model').value;
          const pooling = document.getElementById('pooling').value;
          showCalculations(timeline, model, pooling);
          
          // Debug: log the timeline data
          console.log('Timeline data:', timeline);
        } catch (err) {
          console.error('runOnce error:', err);
          document.getElementById('status').textContent = 'Error: ' + (err.message || err);
        }
      }

      document.getElementById('run').addEventListener('click', () => runOnce(false));
      document.getElementById('newGraph').addEventListener('click', () => runOnce(true));
      runOnce(false);  // initial run with fixed seed
    });
  </script>
</body>
</html>